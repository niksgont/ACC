// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.typecheck;

import org.syntax.stella.Absyn.*;
import org.syntax.stella.PrettyPrinter;

import java.util.HashMap;


/*** Visitor Design Pattern for TypeCheck. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the org.syntax.stella.Absyn.Type and ContextAndReturnType parameters with the desired return
   and context types.*/

public class VisitTypeCheck {
    public static final class A {
        HashMap<String, org.syntax.stella.Absyn.Type> IdentTypes;
        org.syntax.stella.Absyn.Type expectedType;

        public A(HashMap<String, Type> IdentTypes, Type expectedType) {
            this.IdentTypes = IdentTypes;
            this.expectedType = expectedType;
        }
    }

    public static class LanguageDeclVisitor implements org.syntax.stella.Absyn.LanguageDecl.Visitor<org.syntax.stella.Absyn.Type, A> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.LanguageCore p, A arg) { /* Code for LanguageCore goes here */
            return null;
        }
    }

    public static class ExtensionVisitor implements org.syntax.stella.Absyn.Extension.Visitor<org.syntax.stella.Absyn.Type, A> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.AnExtension p, A arg) { /* Code for AnExtension goes here */
            for (String x : p.listextensionname_) {
                //x;
            }
            return null;
        }
    }

    public static class AnnotationVisitor implements org.syntax.stella.Absyn.Annotation.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.InlineAnnotation p, A arg) { /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ProgramVisitor implements org.syntax.stella.Absyn.Program.Visitor<org.syntax.stella.Absyn.Type, A> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.AProgram p, A arg) { /* Code for AProgram goes here */
            p.languagedecl_.accept(new LanguageDeclVisitor(), arg);
            for (org.syntax.stella.Absyn.Extension x : p.listextension_) {
                x.accept(new ExtensionVisitor(), arg);
            }
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), arg);
            }
            if (!arg.IdentTypes.containsKey("main")) throw new TypeCheckException("ERROR_MISSING_MAIN");
            return null;
        }
    }

    public class DeclVisitor implements org.syntax.stella.Absyn.Decl.Visitor<org.syntax.stella.Absyn.Type, A> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.DeclFun p, A arg) { /* Code for DeclFun goes here */

            for (org.syntax.stella.Absyn.Annotation x : p.listannotation_) {
                x.accept(new AnnotationVisitor(), arg);
            }
            //p.stellaident_;
            for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor(), arg);
            }
            p.returntype_.accept(new ReturnTypeVisitor(), arg);
            p.throwtype_.accept(new ThrowTypeVisitor(), arg);
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), arg);
            }
            AParamDecl paramDecl = (AParamDecl) p.listparamdecl_.get(0);
            HashMap<String, Type> newIdentTypes = new HashMap<>(arg.IdentTypes);
            newIdentTypes.put(paramDecl.stellaident_, paramDecl.type_);

            Type returnType = p.returntype_.accept(new ReturnType.Visitor<>() {
                @Override
                public Type visit(NoReturnType p, Object arg) {
                    throw new TypeCheckException("ERROR_NO_RETURN_TYPE");
                }

                @Override
                public Type visit(SomeReturnType p, Object arg) {
                    return p.type_;
                }
            }, null);

            p.expr_.accept(new ExprVisitor(), new A(newIdentTypes, returnType));

            ListType argListType = new ListType();
            argListType.add(paramDecl.type_);
            arg.IdentTypes.put(p.stellaident_, new TypeFun(argListType, returnType));
            return null;
        }

        @Override
        public Type visit(DeclFunGeneric p, A arg) {
            return null;
        }

        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.DeclTypeAlias p, A arg) { /* Code for DeclTypeAlias goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(DeclExceptionType p, A arg) {
            return null;
        }

        @Override
        public Type visit(DeclExceptionVariant p, A arg) {
            return null;
        }
    }

    public class LocalDeclVisitor implements org.syntax.stella.Absyn.LocalDecl.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.ALocalDecl p, A arg) { /* Code for ALocalDecl goes here */
            p.decl_.accept(new DeclVisitor(), arg);
            return null;
        }
    }

    public class ParamDeclVisitor implements org.syntax.stella.Absyn.ParamDecl.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.AParamDecl p, A arg) { /* Code for AParamDecl goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class ReturnTypeVisitor implements org.syntax.stella.Absyn.ReturnType.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.NoReturnType p, A arg) { /* Code for NoReturnType goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeReturnType p, A arg) { /* Code for SomeReturnType goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class ThrowTypeVisitor implements org.syntax.stella.Absyn.ThrowType.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.NoThrowType p, A arg) { /* Code for NoThrowType goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeThrowType p, A arg) { /* Code for SomeThrowType goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }
    }

    public class TypeVisitor implements org.syntax.stella.Absyn.Type.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.TypeFun p, A arg) { /* Code for TypeFun goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeForAll p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeRec p, A arg) { /* Code for TypeRec goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeSum p, A arg) { /* Code for TypeSum goes here */
            p.type_1.accept(new TypeVisitor(), arg);
            p.type_2.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeTuple p, A arg) { /* Code for TypeTuple goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeRecord p, A arg) { /* Code for TypeRecord goes here */
            for (org.syntax.stella.Absyn.RecordFieldType x : p.listrecordfieldtype_) {
                x.accept(new RecordFieldTypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeVariant p, A arg) { /* Code for TypeVariant goes here */
            for (org.syntax.stella.Absyn.VariantFieldType x : p.listvariantfieldtype_) {
                x.accept(new VariantFieldTypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeList p, A arg) { /* Code for TypeList goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeBool p, A arg) { /* Code for TypeBool goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeNat p, A arg) { /* Code for TypeNat goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeUnit p, A arg) { /* Code for TypeUnit goes here */
            return null;
        }

        @Override
        public Type visit(TypeTop p, A arg) {
            return null;
        }

        @Override
        public Type visit(TypeBottom p, A arg) {
            return null;
        }

        @Override
        public Type visit(TypeRef p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeVar p, A arg) { /* Code for TypeVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class MatchCaseVisitor implements org.syntax.stella.Absyn.MatchCase.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.AMatchCase p, A arg) { /* Code for AMatchCase goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class OptionalTypingVisitor implements org.syntax.stella.Absyn.OptionalTyping.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.NoTyping p, A arg) { /* Code for NoTyping goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeTyping p, A arg) { /* Code for SomeTyping goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class PatternDataVisitor implements org.syntax.stella.Absyn.PatternData.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.NoPatternData p, A arg) { /* Code for NoPatternData goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomePatternData p, A arg) { /* Code for SomePatternData goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class ExprDataVisitor implements org.syntax.stella.Absyn.ExprData.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.NoExprData p, A arg) { /* Code for NoExprData goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeExprData p, A arg) { /* Code for SomeExprData goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class PatternVisitor implements org.syntax.stella.Absyn.Pattern.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.PatternVariant p, A arg) { /* Code for PatternVariant goes here */
            //p.stellaident_;
            p.patterndata_.accept(new PatternDataVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInl p, A arg) { /* Code for PatternInl goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInr p, A arg) { /* Code for PatternInr goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternTuple p, A arg) { /* Code for PatternTuple goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternRecord p, A arg) { /* Code for PatternRecord goes here */
            for (org.syntax.stella.Absyn.LabelledPattern x : p.listlabelledpattern_) {
                x.accept(new LabelledPatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternList p, A arg) { /* Code for PatternList goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternCons p, A arg) { /* Code for PatternCons goes here */
            p.pattern_1.accept(new PatternVisitor(), arg);
            p.pattern_2.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternFalse p, A arg) { /* Code for PatternFalse goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternTrue p, A arg) { /* Code for PatternTrue goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternUnit p, A arg) { /* Code for PatternUnit goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInt p, A arg) { /* Code for PatternInt goes here */
            //p.integer_;
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternSucc p, A arg) {
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternVar p, A arg) { /* Code for PatternVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class LabelledPatternVisitor implements org.syntax.stella.Absyn.LabelledPattern.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.ALabelledPattern p, A arg) { /* Code for ALabelledPattern goes here */
            //p.stellaident_;
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class BindingVisitor implements org.syntax.stella.Absyn.Binding.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.ABinding p, A arg) { /* Code for ABinding goes here */
            //p.stellaident_;
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class ExprVisitor implements org.syntax.stella.Absyn.Expr.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.Sequence p, A arg) { /* Code for Sequence goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(Assign p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.If p, A arg) {
            p.expr_1.accept(new ExprVisitor(), new A(arg.IdentTypes, new TypeBool()));
            Type thenType = p.expr_2.accept(new ExprVisitor(), arg);
            p.expr_3.accept(new ExprVisitor(), new A(arg.IdentTypes, thenType));
            if (arg.expectedType == null) {
                return thenType;
            }
            if (thenType.equals(arg.expectedType)) {
                return thenType;
            }
            throw new TypeCheckException("UNEXPECTED_TYPE_FOR_EXPRESSION 1");
        }

        public Type visit(org.syntax.stella.Absyn.Let p, A arg) { /* Code for Let goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LetRec p, A arg) { /* Code for LetRec goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeAbstraction p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LessThan p, A arg) { /* Code for LessThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LessThanOrEqual p, A arg) { /* Code for LessThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.GreaterThan p, A arg) { /* Code for GreaterThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.GreaterThanOrEqual p, A arg) { /* Code for GreaterThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Equal p, A arg) { /* Code for Equal goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.NotEqual p, A arg) { /* Code for NotEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeAsc p, A arg) { /* Code for TypeAsc goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeCast p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Abstraction p, A arg) { /* Code for Abstraction goes here */
            HashMap<String, Type> newContext = new HashMap<>(arg.IdentTypes);
            AParamDecl paramDecl = (AParamDecl) p.listparamdecl_.get(0);
            newContext.put(paramDecl.stellaident_, paramDecl.type_);

            Type bodyType = null;
            if (arg.expectedType != null) {
                if (arg.expectedType instanceof TypeFun) {
                    if (((TypeFun) arg.expectedType).listtype_.get(0) == null) {
                        bodyType = ((TypeFun) arg.expectedType).type_;
                    }
                    if (paramDecl.type_.equals(((TypeFun) arg.expectedType).listtype_.get(0))) {
                        bodyType = ((TypeFun) arg.expectedType).type_;
                    } else {
                        throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_PARAMETER");
                    }
                } else {
                    throw new TypeCheckException("ERROR_UNEXPECTED_LAMBDA");
                }
            }
            bodyType = p.expr_.accept(new ExprVisitor(), new A(newContext, bodyType));

            ListType argType = new ListType();
            argType.add(paramDecl.type_);
            Type currentType = new TypeFun(argType, bodyType);
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_NOT_A_FUNCTION");
        }

        public Type visit(org.syntax.stella.Absyn.Variant p, A arg) { /* Code for Variant goes here */
            //p.stellaident_;
            p.exprdata_.accept(new ExprDataVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Match p, A arg) { /* Code for Match goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            for (org.syntax.stella.Absyn.MatchCase x : p.listmatchcase_) {
                x.accept(new MatchCaseVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.List p, A arg) { /* Code for List goes here */
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                x.accept(new ExprVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Add p, A arg) { /* Code for Add goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Subtract p, A arg) { /* Code for Subtract goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LogicOr p, A arg) { /* Code for LogicOr goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Multiply p, A arg) { /* Code for Multiply goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Divide p, A arg) { /* Code for Divide goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LogicAnd p, A arg) { /* Code for LogicAnd goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(Ref p, A arg) {
            return null;
        }

        @Override
        public Type visit(Deref p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Application p, A arg) { /* Code for Application goes here */
            Type funType = p.expr_.accept(new ExprVisitor(), new A(arg.IdentTypes, null));
            if (funType instanceof TypeFun) {
                Type argType = ((TypeFun) funType).listtype_.get(0);
                Type retType = ((TypeFun) funType).type_;
                p.listexpr_.get(0).accept(new ExprVisitor(), new A(arg.IdentTypes, argType));
                if (arg.expectedType == null) {
                    return retType;
                }
                if (retType.equals(arg.expectedType)) {
                    return arg.expectedType;
                }
                throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

            } else {
                throw new TypeCheckException("ERROR_NOT_A_FUNCTION");
            }
        }

        @Override
        public Type visit(TypeApplication p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.DotRecord p, A arg) { /* Code for DotRecord goes here */
            Type dotType = p.expr_.accept(new ExprVisitor(), new A(arg.IdentTypes, null));
            if (dotType instanceof TypeRecord) {
                ListRecordFieldType params = ((TypeRecord) dotType).listrecordfieldtype_;
                for (RecordFieldType i : params)
                    if (((ARecordFieldType) i).stellaident_.equals(p.stellaident_)) {
                        if (arg.expectedType == null) {
                            return ((ARecordFieldType) i).type_;
                        }
                        if (((ARecordFieldType) i).type_.equals(arg.expectedType)) {
                            return arg.expectedType;
                        }
                        throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                    }


                throw new TypeCheckException("ERROR_UNEXPECTED_FIELD_ACCESS");
            } else throw new TypeCheckException("ERROR_NOT_A_RECORD");

            //p.stellaident_;
            // return null;
        }

        public Type visit(org.syntax.stella.Absyn.DotTuple p, A arg) { /* Code for DotTuple goes here */
            Type dotType = p.expr_.accept(new ExprVisitor(), new A(arg.IdentTypes, null));
            if (!(dotType instanceof TypeTuple))
            {
                throw new TypeCheckException("ERROR_NOT_A_TUPLE");
            }
            else{
                ListType params = ((TypeTuple) dotType).listtype_;
                if (p.integer_ < 1) throw new TypeCheckException("ERROR_TUPLE_INDEX_OUT_OF_BOUNDS");
                if (p.integer_ > ((TypeTuple) dotType).listtype_.size())
                    throw new TypeCheckException("ERROR_TUPLE_INDEX_OUT_OF_BOUNDS");
                for (int index = 0; index < params.size(); index++){
                    //if (arg.expectedType == null) return param;
                    if (params.get(index).equals(arg.expectedType)) return params.get(index);
                }
                throw new TypeCheckException("ERROR_MISSING_RECORD_FIELDS");
            }
        }

        public Type visit(org.syntax.stella.Absyn.Tuple p, A arg) { /* Code for Tuple goes here */
            ListType params = new ListType();
            if (arg.expectedType != null)
                if (!(arg.expectedType instanceof TypeTuple)) throw new TypeCheckException("ERROR_UNEXPECTED_TUPLE");


            TypeTuple typeTuple = (TypeTuple) arg.expectedType;

            int i = 0;
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                Type type;
                if (typeTuple != null) {
                    type = x.accept(new ExprVisitor(), new A(arg.IdentTypes, typeTuple.listtype_.get(i)));
                } else {
                    type = x.accept(new ExprVisitor(), arg);
                }
                params.add(type);
                i++;
            }

            Type recordType = new TypeTuple(params);

            if (arg.expectedType != null) {
                assert typeTuple != null;
                if (p.listexpr_.size() != typeTuple.listtype_.size()) {
                    throw new TypeCheckException("ERROR_UNEXPECTED_TUPLE_LENGTH");
                }
            }
            if (arg.expectedType == null) {
                return recordType;
            }
            if (recordType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            //return null;
        }

        public Type visit(org.syntax.stella.Absyn.Record p, A arg) {

            ListRecordFieldType params = new ListRecordFieldType();
            if (arg.expectedType != null) if (!(arg.expectedType instanceof TypeRecord)) {
                throw new TypeCheckException("ERROR_UNEXPECTED_RECORD");
            }
            int i = 0;
            TypeRecord typeRecord = (TypeRecord) arg.expectedType;
            for (org.syntax.stella.Absyn.Binding x : p.listbinding_) {
                Type type;
                if (typeRecord != null) {
                    type = x.accept(new BindingVisitor(), new A(arg.IdentTypes, ((ARecordFieldType) typeRecord.listrecordfieldtype_.get(i)).type_));
                } else {
                    type = x.accept(new BindingVisitor(), arg);
                }
                params.add(new ARecordFieldType(((ABinding) x).stellaident_, type));
                i++;
            }

            if (arg.expectedType != null) {
                assert typeRecord != null;
                if (p.listbinding_.size() != typeRecord.listrecordfieldtype_.size()) {
                    throw new TypeCheckException("ERROR_UNEXPECTED_RECORD_FIELDS");
                }
            }
            Type recordType = new TypeRecord(params);
            if (arg.expectedType == null) {
                return recordType;
            }
            if (recordType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(org.syntax.stella.Absyn.ConsList p, A arg) { /* Code for ConsList goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Head p, A arg) { /* Code for Head goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.IsEmpty p, A arg) { /* Code for IsEmpty goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Tail p, A arg) { /* Code for Tail goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(Panic p, A arg) {
            return null;
        }

        @Override
        public Type visit(Throw p, A arg) {
            return null;
        }

        @Override
        public Type visit(TryCatch p, A arg) {
            return null;
        }

        @Override
        public Type visit(TryWith p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Inl p, A arg) { /* Code for Inl goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Inr p, A arg) { /* Code for Inr goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Succ p, A arg) { /* Code for Succ goes here */
            //System.out.println("Visiting succ");
            p.expr_.accept(new ExprVisitor(), new A(arg.IdentTypes, new TypeNat()));
            Type currentType = new TypeNat();
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(org.syntax.stella.Absyn.LogicNot p, A arg) { /* Code for LogicNot goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Pred p, A arg) { /* Code for Pred goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.IsZero p, A arg) { /* Code for IsZero goes here */
            p.expr_.accept(new ExprVisitor(), new A(arg.IdentTypes, new TypeNat()));
            Type currentType = new TypeBool();
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(org.syntax.stella.Absyn.Fix p, A arg) { /* Code for Fix goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.NatRec p, A arg) { /* Code for NatRec goes here */
            p.expr_1.accept(new ExprVisitor(), new A(arg.IdentTypes, new TypeNat()));
            Type returnType = p.expr_2.accept(new ExprVisitor(), arg);
            ListType arg1 = new ListType();
            arg1.add(new TypeNat());
            ListType arg2 = new ListType();
            arg2.add(returnType);
            Type stepType = new TypeFun(arg1, new TypeFun(arg2, returnType));
            p.expr_3.accept(new ExprVisitor(), new A(arg.IdentTypes, stepType));
            if (arg.expectedType == null) {
                return returnType;
            }
            if (returnType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(org.syntax.stella.Absyn.Fold p, A arg) { /* Code for Fold goes here */
            p.type_.accept(new TypeVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Unfold p, A arg) { /* Code for Unfold goes here */
            p.type_.accept(new TypeVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.ConstTrue p, A arg) { /* Code for ConstTrue goes here */
            Type currentType = new TypeBool();
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

        }

        public Type visit(org.syntax.stella.Absyn.ConstFalse p, A arg) { /* Code for ConstFalse goes here */
            Type currentType = new TypeBool();
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }

            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(org.syntax.stella.Absyn.ConstUnit p, A arg) { /* Code for ConstUnit goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.ConstInt p, A arg) { /* Code for ConstInt goes here */
            //p.integer_;
            Type currentType = new TypeNat();
            if (arg.expectedType == null) {
                return currentType;
            }
            if (currentType.equals(arg.expectedType)) {
                return arg.expectedType;
            }
            throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        @Override
        public Type visit(ConstMemory p, A arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Var p, A arg) {
            Type varType = arg.IdentTypes.get(p.stellaident_);
            if (varType == null) {
                throw new TypeCheckException(" ERROR_UNDEFINED_VARIABLE");
            } else {
                if (arg.expectedType == null) {
                    return varType;
                }
                if (varType.equals(arg.expectedType)) {
                    return arg.expectedType;
                }
                throw new TypeCheckException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

            }
        }
    }

    public class PatternBindingVisitor implements org.syntax.stella.Absyn.PatternBinding.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.APatternBinding p, A arg) { /* Code for APatternBinding goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class VariantFieldTypeVisitor implements org.syntax.stella.Absyn.VariantFieldType.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.AVariantFieldType p, A arg) { /* Code for AVariantFieldType goes here */
            //p.stellaident_;
            p.optionaltyping_.accept(new OptionalTypingVisitor(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor implements org.syntax.stella.Absyn.RecordFieldType.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.ARecordFieldType p, A arg) { /* Code for ARecordFieldType goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class TypingVisitor implements org.syntax.stella.Absyn.Typing.Visitor<org.syntax.stella.Absyn.Type, A> {
        public Type visit(org.syntax.stella.Absyn.ATyping p, A arg) { /* Code for ATyping goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }
}